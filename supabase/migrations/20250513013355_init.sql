-- Create enum type for user types
CREATE TYPE user_type AS ENUM ('TALENT', 'ORGANIZER');

-- Create a table for public users
create table users (
  id uuid references auth.users on delete cascade not null primary key,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  email text unique not null,
  phone text,
  first_name text,
  last_name text,
  city text,
  state text,
  metadata jsonb default '{}'::jsonb,
  avatar_url text,
  user_type user_type NOT NULL DEFAULT 'TALENT',

  constraint phone_length check (char_length(phone) <= 15)
);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
begin
  insert into public.users (id, email, user_type)
  values (
    new.id, 
    new.email,
    coalesce(
      (new.raw_user_meta_data->>'user_type')::public.user_type,
      'TALENT'
    )
  );
  
  -- Update the auth.users table to sync raw_app_meta_data with raw_user_meta_data user_type
  update auth.users
  set raw_app_meta_data = coalesce(raw_app_meta_data, '{}'::jsonb) || 
    jsonb_build_object('user_type', coalesce(
      (new.raw_user_meta_data->>'user_type'),
      'TALENT'
    ))
  where id = new.id;

  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create a skills table
create table skills (
  id bigint primary key generated by default as identity,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  name text not null,
  image_url text
);

-- Create a talent_skills table
create table talent_skills (
  id bigint primary key generated by default as identity,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  user_id uuid references users(id) on delete cascade not null,
  skill_id bigint references skills(id) on delete cascade not null,
  summary text not null,
  years_of_experience numeric(4,1) not null,
  hourly_rate numeric(10,2) not null,
  youtube_url text,
  image_urls text[] default array[]::text[] not null,
  constraint talent_skills_image_urls_length check (array_length(image_urls, 1) <= 5)
);

-- Create unique index to prevent duplicate skills for a user
create unique index talent_skills_user_skill_unique on talent_skills(user_id, skill_id);

-- Create a talent_blockouts table
create table talent_blockouts (
  id bigint primary key generated by default as identity,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  talent_id uuid references users(id) on delete cascade not null,
  title text not null,
  description text,
  
  -- Unified time handling - always use timestamps for consistency
  start_time timestamp with time zone not null,
  end_time timestamp with time zone not null,
  
  -- Simple flag for all-day events
  is_all_day boolean default false,
  
  -- Timezone for display purposes (useful for all-day events)
  timezone text default 'UTC',
  
  -- Recurrence using RRULE standard (RFC 5545)
  is_recurring boolean default false,
  rrule text, -- RRULE string for maximum flexibility
  
  -- Status and metadata
  is_active boolean default true,
  metadata jsonb default '{}'::jsonb,
  
  -- Simple constraints
  constraint valid_time_order check (start_time < end_time),
  constraint valid_recurrence check (
    (is_recurring = false) or
    (is_recurring = true and rrule is not null)
  )
);

-- Create indexes for better query performance
create index talent_blockouts_talent_id_idx on talent_blockouts(talent_id);
create index talent_blockouts_start_time_idx on talent_blockouts(start_time);
create index talent_blockouts_end_time_idx on talent_blockouts(end_time);
create index talent_blockouts_active_idx on talent_blockouts(is_active) where is_active = true;
create index talent_blockouts_recurring_idx on talent_blockouts(is_recurring) where is_recurring = true;
create index talent_blockouts_all_day_idx on talent_blockouts(is_all_day);

-- Add index for user_type for better query performance
create index idx_users_user_type on users(user_type);

-- Set up Row Level Security (RLS)
alter table users enable row level security;
alter table skills enable row level security;
alter table talent_skills enable row level security;
alter table talent_blockouts enable row level security;

-- Users RLS policies
create policy "Public users are viewable by authenticated users."
  on users as permissive for select to authenticated
  using (true);

create policy "Users can insert their own profile."
  on users for insert to authenticated
  with check ((select auth.uid()) = id);

create policy "Users can update own profile."
  on users for update to authenticated
  using ((select auth.uid()) = id)       -- For reading
  with check ((select auth.uid()) = id); -- For writing

-- Skills RLS policies
create policy "Skills are viewable by authenticated users."
  on skills for select to authenticated
  using (true);

-- Talent Skills RLS policies
create policy "Talent skills are viewable by authenticated users."
  on talent_skills for select to authenticated
  using (true);

create policy "Users can insert their own talent skills."
  on talent_skills for insert to authenticated
  with check ((select auth.uid()) = user_id);

create policy "Users can update their own talent skills."
  on talent_skills for update to authenticated
  using ((select auth.uid()) = user_id)
  with check ((select auth.uid()) = user_id);

create policy "Users can delete their own talent skills."
  on talent_skills for delete to authenticated
  using ((select auth.uid()) = user_id);

-- Talent Blockouts RLS policies
create policy "Talent blockouts are viewable by authenticated users."
  on talent_blockouts for select to authenticated
  using (true);

create policy "Users can insert their own talent blockouts."
  on talent_blockouts for insert to authenticated
  with check ((select auth.uid()) = talent_id);

create policy "Users can update their own talent blockouts."
  on talent_blockouts for update to authenticated
  using ((select auth.uid()) = talent_id)
  with check ((select auth.uid()) = talent_id);

create policy "Users can delete their own talent blockouts."
  on talent_blockouts for delete to authenticated
  using ((select auth.uid()) = talent_id);

-- Create a view that joins users and their talent skills and blockouts
create view user_talent_skills as
with user_skills_agg as (
  select 
    u.id as user_id,
    coalesce(
      jsonb_agg(
        jsonb_build_object(
          'talent_skill_id', ts.id,
          'skill_id', ts.skill_id,
          'skill_name', s.name,
          'skill_image_url', s.image_url,
          'summary', ts.summary,
          'years_of_experience', ts.years_of_experience,
          'hourly_rate', ts.hourly_rate,
          'youtube_url', ts.youtube_url,
          'skill_image_urls', ts.image_urls,
          'created_at', ts.created_at,
          'updated_at', ts.updated_at
        )
      ) filter (where ts.id is not null),
      '[]'::jsonb
    ) as talent_skills,
    array_agg(ts.skill_id) filter (where ts.skill_id is not null) as skill_ids,
    array_agg(lower(replace(s.name, ' ', ''))) filter (where s.name is not null) as skill_names
  from users u
  left join talent_skills ts on u.id = ts.user_id
  left join skills s on ts.skill_id = s.id
  where u.user_type = 'TALENT'
  group by u.id
),
user_blockouts_agg as (
  select 
    u.id as user_id,
    coalesce(
      jsonb_agg(
        jsonb_build_object(
          'blockout_id', tb.id,
          'title', tb.title,
          'description', tb.description,
          'start_time', tb.start_time,
          'end_time', tb.end_time,
          'is_all_day', tb.is_all_day,
          'timezone', tb.timezone,
          'is_recurring', tb.is_recurring,
          'rrule', tb.rrule,
          'is_active', tb.is_active,
          'metadata', tb.metadata,
          'created_at', tb.created_at,
          'updated_at', tb.updated_at
        )
      ) filter (where tb.id is not null and tb.is_active = true),
      '[]'::jsonb
    ) as talent_blockouts
  from users u
  left join talent_blockouts tb on u.id = tb.talent_id
  where u.user_type = 'TALENT'
  group by u.id
)
select 
  u.*,
  coalesce(usa.talent_skills, '[]'::jsonb) as talent_skills,
  coalesce(uba.talent_blockouts, '[]'::jsonb) as talent_blockouts,
  usa.skill_ids,
  usa.skill_names
from users u
left join user_skills_agg usa on u.id = usa.user_id
left join user_blockouts_agg uba on u.id = uba.user_id
where u.user_type = 'TALENT';

-- Note: Views inherit RLS policies from their underlying tables
-- The security is enforced through the existing RLS policies on users, talent_skills, talent_blockouts, and skills tables


-- STORAGE
-- Set up Storage!
insert into storage.buckets (id, name, public)
  values ('avatars', 'avatars', true);

create policy "Avatars are publicly accessible."
  on storage.objects for select to authenticated
  using (bucket_id = 'avatars');

create policy "Users can upload avatars."
  on storage.objects for insert to authenticated
  with check (bucket_id = 'avatars');

insert into storage.buckets (id, name, public)
  values ('skill-images', 'skill-images', true);

-- Set up access controls for skill images storage
create policy "Skill images are publicly accessible."
  on storage.objects for select to authenticated
  using (bucket_id = 'skill-images');

create policy "Users can upload skill images."
  on storage.objects for insert to authenticated
  with check (bucket_id = 'skill-images');

-- TODO: Refactor the above and replace it with the following, which restricts uploads to a user's folder.
-- create policy "Allow authenticated uploads"
-- on storage.objects
-- for insert
-- to authenticated
-- with check (
--   bucket_id = 'my_bucket_id' and
--   (storage.foldername(name))[1] = (select auth.uid()::text)
-- );

create policy "Users can update their own skill images."
  on storage.objects for update to authenticated
  -- using (bucket_id = 'skill-images' and (auth.uid())::text = owner);
  using (bucket_id = 'skill-images');

create policy "Users can delete their own skill images."
  on storage.objects for delete to authenticated
  -- using (bucket_id = 'skill-images' and (auth.uid())::text = owner);
  using (bucket_id = 'skill-images');