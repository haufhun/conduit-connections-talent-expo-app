-- Create a table for public users
create table users (
  id uuid references auth.users on delete cascade not null primary key,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  email text unique not null,
  phone text,
  first_name text,
  last_name text,
  city text,
  state text,
  metadata jsonb default '{}'::jsonb,
  avatar_url text,

  constraint phone_length check (char_length(phone) <= 15)
);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
begin
  insert into public.users (id, email)
  values (new.id, new.email);
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create a skills table
create table skills (
  id bigint primary key generated by default as identity,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  name text not null,
  image_url text
);

-- Create a talent_skills table
create table talent_skills (
  id bigint primary key generated by default as identity,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  user_id uuid references users(id) on delete cascade not null,
  skill_id bigint references skills(id) on delete cascade not null,
  summary text,
  years_of_experience numeric(4,1),
  image_urls text[] default array[]::text[],
  constraint talent_skills_image_urls_length check (array_length(image_urls, 1) <= 5)
);

-- Create unique constraint to prevent duplicate skills for a user
create unique index talent_skills_user_skill_unique on talent_skills(user_id, skill_id);

-- Set up Row Level Security (RLS)
alter table users enable row level security;
alter table skills enable row level security;
alter table talent_skills enable row level security;

-- Users RLS policies
create policy "Public users are viewable by authenticated users."
  on users as permissive for select to authenticated
  using (true);

create policy "Users can insert their own profile."
  on users for insert to authenticated
  with check ((select auth.uid()) = id);

create policy "Users can update own profile."
  on users for update to authenticated
  using ((select auth.uid()) = id)       -- For reading
  with check ((select auth.uid()) = id); -- For writing

-- Skills RLS policies
create policy "Skills are viewable by authenticated users."
  on skills for select to authenticated
  using (true);

-- Talent Skills RLS policies
create policy "Talent skills are viewable by authenticated users."
  on talent_skills for select to authenticated
  using (true);

create policy "Users can insert their own talent skills."
  on talent_skills for insert to authenticated
  with check ((select auth.uid()) = user_id);

create policy "Users can update their own talent skills."
  on talent_skills for update to authenticated
  using ((select auth.uid()) = user_id)
  with check ((select auth.uid()) = user_id);

create policy "Users can delete their own talent skills."
  on talent_skills for delete to authenticated
  using ((select auth.uid()) = user_id);



-- STORAGE
-- Set up Storage!
insert into storage.buckets (id, name, public)
  values ('avatars', 'avatars', true);


insert into storage.buckets (id, name, public)
  values ('skill-images', 'skill-images', true);

-- Set up access controls for skill images storage
create policy "Skill images are publicly accessible."
  on storage.objects for select to authenticated
  using (bucket_id = 'skill-images');

create policy "Users can upload skill images."
  on storage.objects for insert to authenticated
  with check (bucket_id = 'skill-images');

create policy "Users can update their own skill images."
  on storage.objects for update to authenticated
  -- using (bucket_id = 'skill-images' and (auth.uid())::text = owner);
  using (bucket_id = 'skill-images');

create policy "Users can delete their own skill images."
  on storage.objects for delete to authenticated
  -- using (bucket_id = 'skill-images' and (auth.uid())::text = owner);
  using (bucket_id = 'skill-images');